/**
 * Новый вариант использования plugins. Принимает только id плагинов
 */
plugins {
    id 'java'
}

/**
 * Один из вариантов использования plugins: через отдельный скрипт файл
 */
apply from: 'script.gradle'
/**
 * Второй вариант использования plugins: через создание класса
 */
apply plugin: CustomPlugin.class

/**
 * В блоке repositories вы можете указать различные типы репозиториев, такие как:
 * <p></p>
 * mavenCentral(): Это один из стандартных удаленных репозиториев Maven. Он содержит огромное количество библиотек и
 * зависимостей для Java и других языков.
 * <p></p>
 * jcenter(): Еще один стандартный удаленный репозиторий, поддерживаемый Bintray. Он также содержит множество библиотек
 * для различных языков программирования и платформ.
 * <p></p>
 * mavenLocal(): Локальный репозиторий Maven на вашем компьютере. Gradle будет искать зависимости в этом репозитории на
 * вашем локальном компьютере перед тем, как обратиться к удаленным репозиториям.
 * <p></p>
 * flatDir { dirs 'libs' }: Позволяет Gradle искать зависимости в локальной директории libs относительно корня проекта.
 * <p></p>
 * Пример использования repositories в Gradle:
 * <pre>{@code
 * repositories {
 *      mavenCentral()
 *      jcenter()
 *      mavenLocal()
 *      flatDir {
 *          dirs 'libs'
 *      }
 * }
 *}
 * </pre>
 * Этот код указывает Gradle использовать стандартные удаленные репозитории Maven (mavenCentral и jcenter), локальный
 * репозиторий Maven (mavenLocal) и локальную директорию libs, которая находится в корне проекта. Gradle будет искать
 * зависимости в этих репозиториях при выполнении сборки проекта и загрузке необходимых библиотек.
 */
repositories {
    // ~/.gradle/cashes --offline
    // ~/.m2/repository

    /**
     * Установка локального репозитория.
     * Например, репозиторий компании
     */
    maven {
        name "nexus alex"
        url "https://nexus.alex/repository"
    }
    mavenLocal()
    mavenCentral()
}

/**
 * В Gradle sourceSets - это механизм, который позволяет организовывать и настраивать исходные наборы (source sets) в проекте. Исходные наборы представляют собой группы исходных файлов, которые Gradle использует для выполнения различных задач, таких как компиляция, тестирование и создание дистрибутивов.
 * <p></p>
 * Обычно в проекте есть несколько исходных наборов, таких как исходный код основного приложения, тестовый код, ресурсы и тестовые ресурсы. sourceSets позволяет явно определять эти наборы и настраивать их параметры.
 * <p></p>
 * Пример конфигурации sourceSets в Gradle для Java проекта может выглядеть следующим образом:
 * <pre>{@code
 * sourceSets {
 *      main {
 *          java {
 *              srcDir 'src/main/java'
 *          }
 *          resources {
 *              srcDir 'src/main/resources'
 *          }
 *      }
 *      test {
 *          java {
 *              srcDir 'src/test/java'
 *          }
 *          resources {
 *              srcDir 'src/test/resources'
 *          }
 *      }
 * }
 *}
 * </pre>
 * Этот код определяет два исходных набора: main и test. Внутри каждого набора определены каталоги исходных файлов Java (java) и ресурсов (resources). Здесь указываются каталоги, в которых Gradle будет искать исходные файлы Java и ресурсы для каждого набора.
 * <p></p>
 * После того как исходные наборы определены с помощью sourceSets, вы можете использовать их для настройки других задач Gradle, таких как компиляция, тестирование, упаковка и т. д. Это позволяет вам более гибко управлять вашим проектом и его структурой.
 */
sourceSets {
    main {

    }

    test {

    }
}

/**
 * В Gradle блок dependencies используется для определения зависимостей вашего проекта. Зависимости представляют собой
 * внешние библиотеки или модули, которые ваш проект использует во время сборки или выполнения.
 * <p></p>
 * Зависимости могут быть внешними библиотеками, такими как библиотеки, предоставляемые Maven Central или JCenter, или
 * они могут быть локальными, находящимися внутри вашего проекта или в локальном репозитории.
 * <p></p>
 * Пример использования блока dependencies в Gradle:
 * <pre>
 * {@code
 *  dependencies {
 *      implementation 'com.google.guava:guava:30.1.1-jre'
 *      implementation 'org.apache.commons:commons-lang3:3.12.0'
 *      testImplementation 'junit:junit:4.13.2'
 *      testImplementation 'org.mockito:mockito-core:4.2.0'
 *  }
 *}
 * </pre>
 * Этот код определяет зависимости для вашего проекта:
 * <p></p>
 * implementation: Эта конфигурация используется для зависимостей, которые должны быть доступны во время компиляции и
 * выполнения вашего проекта.
 * testImplementation: Эта конфигурация используется для зависимостей, которые нужны только во время выполнения тестов.
 * В приведенном примере зависимости включают Guava, Apache Commons Lang для основного приложения, а также JUnit и Mockito
 * для тестирования.
 * <p></p>
 * Gradle автоматически загружает эти зависимости из удаленных репозиториев, указанных в блоке repositories, и может
 * также использовать зависимости, находящиеся в локальной директории проекта.
 */
dependencies {
    /**
     * Пример того, как происходит исключение каких-либо транзитивных зависимостей
     */
    implementation("org.springframework:spring-webmvc:5.3.9") {
//        exclude(group: 'org.springframework', module: 'spring-aop') -> отключение одной зависимости
//        transitive(false) -> отключение всех транзитивных зависимостей
    }

    implementation("org.springframework:spring-aop:5.3.8") {
//        force(true) -> говорим Gradle, что мы хотим использовать именно версию 5.3.8 spring-aop
    }
}

jar {
    def jars = configurations.runtimeClasspath.files.collect {
        "lib/$it.name"
    }

    manifest {
        attributes 'Main-Class': 'com.alex.HelloWorld',
                'Class-Path': jars.join(' ')
    }
}

/**
 * В Gradle, объект configurations используется для определения и настройки конфигураций зависимостей. Конфигурации
 * позволяют группировать зависимости по типам использования или области видимости в проекте.
 * <p>
 * Каждый проект в Gradle по умолчанию имеет несколько стандартных конфигураций, таких как implementation, compile,
 * testImplementation, runtime, archives и т. д. Однако вы также можете определять свои собственные пользовательские
 * конфигурации.
 * <p>
 * Пример использования configurations в Gradle:
 *
 * <pre>{@code
 *      configurations {
 *          myCustomConfiguration
 *          compileOnly {
 *              extendsFrom implementation
 *          }
 *          myCustomConfiguration {
 *              description = 'My custom configuration'
 *              transitive = true
 *          }
 *      }
 *}
 * </pre>
 * В этом примере мы определяем три различных конфигурации:
 * <p>
 * myCustomConfiguration: Это пользовательская конфигурация, которую мы определили сами. Она может использоваться для
 * определенных случаев в нашем проекте, когда нам нужно группировать зависимости по своему усмотрению.
 * <p>
 * compileOnly: Это стандартная конфигурация, которую мы расширяем с помощью extendsFrom. Здесь мы указываем, что она
 * должна включать все зависимости, объявленные в конфигурации implementation, и добавляем к ним свои собственные.
 * <p>
 * myCustomConfiguration: Еще одна пользовательская конфигурация, в которой мы устанавливаем описание с помощью
 * description и определяем, должны ли зависимости этой конфигурации быть транзитивными (передаваться другим
 * зависимостям) с помощью transitive.
 * <p>
 * Конфигурации configurations позволяют вам более гибко настраивать и управлять зависимостями в вашем проекте,
 * обеспечивая определенные требования в зависимости от конкретной ситуации.
 */
configurations {
    Configuration configuration = getByName("implementation")
    alex {
        description = "alex configuration"
    }
}

task copyAllDependencies(type: Copy) {
    from(configurations.runtimeClasspath.files)
    into("$buildDir/libs/lib")
}

jar.dependsOn copyAllDependencies

/**
 * Plugin - это обычный объект или script (в зависимости от нашего выбора), который
 * содержит функционал, который мы хотим привнести в наш текущий build.gradle.
 * Обычно это tasks.
 * <p></p>
 * compileJava: Эта задача компилирует исходные Java файлы в байт-код Java. Она берет исходные файлы из каталога src/main/java (по умолчанию) и компилирует их в байт-код классов.
 * <p></p>
 * processResources: Эта задача обрабатывает ресурсы проекта, такие как файлы конфигурации, ресурсы изображений и т. д. Она обычно используется для копирования ресурсов из каталога src/main/resources в каталог сборки.
 * <p></p>
 * classes: Эта задача собирает все скомпилированные классы вместе с обработанными ресурсами, создавая набор классов, готовых к упаковке в JAR файл или к другому использованию.
 * <p></p>
 * jar: Эта задача создает JAR (Java Archive) файл проекта. Она берет скомпилированные классы и ресурсы из каталога classes и упаковывает их в JAR файл.
 * <p></p>
 * assemble: Это задача, которая собирает все необходимые компоненты для создания конечной сборки проекта. Обычно включает в себя выполнение задачи jar и любых других необходимых этапов.
 * <p></p>
 * compileTestJava: Эта задача компилирует исходные файлы тестов Java. Она берет исходные файлы из каталога src/test/java (по умолчанию) и компилирует их.
 * <p></p>
 * processTestResources: Эта задача обрабатывает ресурсы, используемые в тестах, такие как файлы конфигурации тестов, тестовые данные и т. д. Она обычно копирует ресурсы из каталога src/test/resources в каталог сборки для тестов.
 * <p></p>
 * testClasses: Эта задача собирает все скомпилированные классы тестов вместе с обработанными тестовыми ресурсами, создавая набор классов, готовых к выполнению тестов.
 * <p></p>
 * test: Эта задача выполняет тесты проекта. Она запускает тестовые классы и проверяет их работу.
 * <p></p>
 * check: Эта задача выполняет проверки кода, такие как статический анализ, выполнение тестов и т. д. Она обычно включает в себя выполнение задачи test и других инструментов анализа кода.
 * <p></p>
 * build: Это задача, которая собирает все необходимые компоненты проекта и создает конечную сборку. Обычно включает в себя выполнение задачи assemble и выполнение всех проверок, определенных в задаче check.
 */
class CustomPlugin implements Plugin<Project> {

    @Override
    void apply(Project project) {
        addHelloTask(project)
    }

    void addHelloTask(Project project) {
        def map = [description: "Hello task", group: "alex", type: DefaultTask.class]
        project.task(map, "hello") {
            println "config phase. Task hello!"
            println "task_description: $description, group: $group, actions: $actions.size()"

            doFirst {
                println "execution phase, Action 1"
            }

            doLast {
                println "execution phase, Action 2"
            }
        }
    }
}